# c动态规划题解

## 动态规划思考问题的要素点：

动态规划的理解：会动的状态的规划方法

> 自问：**动规五部曲**
> **1.dp数组以及下标的含义**
> **2.递推公式**
> **3.dp数组如何初始化**
> **4.dp数组的边界**
> **5.遍历顺序**
> **6.打印dp数组**

题目主要来源：
1
https://www.bilibili.com/video/BV1f5411K7mo/?spm_id_from=333.788&vd_source=b0ad7a11a35f6bb99c79b79b455563fa

#### 一些关于动态规划的直觉

| 所有的动态规划都是一个有限状态自动机，都可以被表示为一个有向无环图 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 如何判定一个问题是搜索还是动态规划？                         | 先将节点抽象关系用边表示，用人脑简单求一次拓扑排序，如果有环，那就一定不是动态规划 |
| 动态规划问题也和数据范围有关                                 | if 数据规模非常大(n=100000000),大概率不是动态规划。          |
| 可重复贡献问题                                               | 回文最长/区间最值                                            |
| 不可重复贡献问题                                             | 回文个数/区间求和                                            |
|                                                              |                                                              |



## 做题格式





```题目描述：
题目来源

题目描述

辅助：
```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.dp数组的边界
5.遍历顺序
6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```




## 上课回忆内容


| 第18周，周三，下午2-4点，机试，然后写解题报告                | 是否解决 | 重要程度 | 下方序号 | 类型 |
| ------------------------------------------------------------ | -------- | -------- | -------- | ---- |
| 二分搜索的搜索范围                                           |          |          |          | 分治 |
| 主定理,时间复杂度公式，                                      | 1        | 必考     | 9        | 分治 |
| 平面最近点对问题                                             |          | 可能考   |          | 分治 |
| 拉格朗日求值法                                               |          |          |          | 分治 |
| 辛普森公式找一个公式拟合积分里的fx                           |          |          |          | 分治 |
| 1m2m5m凑两块，有多少种凑法                                   | 1        |          |          |      |
| 错位排序，怎么证明是对的                                     | 1        | 必考     | 1        |      |
| 矩阵链乘法                                                   | xxx      |          |          |      |
| 第K大数用快排做                                              | 1        | 必考     | 5        | 分治 |
| 矩阵快速幂解决一维递推优化，矩阵快速幂求数列第n项，求前n项和（PPT-7） |          | 必考     | 7        |      |
| 字符串中的最长回文子串                                       | 1        |          | 2        |      |
| 求这个序列中长度大于K的回文子序列有多少                      | 1        | 必考     | 3        |      |
| 编辑距离                                                     | 1        |          |          |      |
| 最长上升子序列                                               | 1        | 必考     |          |      |
| 归并排序                                                     | 1        | 必考     | 4        | 分治 |
| 快速排序                                                     | 1        | 必考     | 6        | 分治 |
| 背包问题                                                     | 1        |          | 8-01     |      |
| 股票问题                                                     | 1        |          |          |      |
| 插值                                                         | 1        |          | 11       | 分治 |
| 取值                                                         | 1        |          |          | 分治 |
| 快速傅里叶变换                                               | 1        | 必考     | 13       | 分治 |
| **Strassen** **矩阵乘法**                                    | 1        | 必考     | 10       | 分治 |
| 逆序对                                                       | 1        |          | 8        | 分治 |
| 多项式表示法 转换( 系数表示法 / 点值表示法 )                 | 1        |          | 12       |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
|                                                              |          |          |          |      |
| 重点页数：12 13 33 34 35                                     |          |          |          |      |








```
写解题报告：
    先写题意，解释题目，建模状态空间的点是什么，边是什么，
    状态怎么设计，
    价值函数如何定义，
    状态转移怎么更新，
    起点是什么，边界是什么，时间复杂度。
```







## -----------------------------------------



## 算法-考试题(高优先级)

### 1.错位排序，从信封中取出信件，求最多能取出多少封信件

```题目描述：
https://www.luogu.com.cn/problem/P1595
某人写了 n 封信和 n 个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。

编程答案：
https://www.bilibili.com/video/BV1c64y1f7XY/?spm_id_from=333.337.search-card.all.click&vd_source=b0ad7a11a35f6bb99c79b79b455563fa

概率论讲解：
https://www.bilibili.com/video/BV19W4y1S77m/?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=b0ad7a11a35f6bb99c79b79b455563fa

```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.dp数组的边界
5.遍历顺序
6.打印dp数组
```


```c++
#include<iostream>
using namespace std;
long long n, a[1000005];
int main()
{

   cin >> n;
   a[0] = 0;
   a[1] = 0;
   a[2] = 1;
   for (int i = 3; i <= n; ++i)
   {
        a[i] = (i - 1) * (a[i - 1] + a[i - 2]);

    }
   cout << a[n] << endl;
   return 0;
}
```



### 2.字符串中的最长回文子串
```题目描述：
https://leetcode.cn/problems/longest-palindromic-subsequence/description/
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
视频讲解:
https://www.bilibili.com/video/BV1d8411K7W6/?vd_source=b0ad7a11a35f6bb99c79b79b455563fa
```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.dp数组的边界
5.遍历顺序
6.打印dp数组
```





```c++

```



### 3.求这个序列中长度大于K的回文子序列有多少



```c++

```













### 4 归并排序


```c++
#include <iostream>
#include <vector>

void merge(std::vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    std::vector<int> L(n1), R(n2);

    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(std::vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    int arr_size = arr.size();

    std::cout << "Given array is \n";
    for (int i = 0; i < arr_size; i++)
        std::cout << arr[i] << " ";

    mergeSort(arr, 0, arr_size - 1);

    std::cout << "\nSorted array is \n";
    for (int i = 0; i < arr_size; i++)
        std::cout << arr[i] << " ";

    return 0;
}


```

### 5 快速排序


```c++
#include <iostream>
#include <vector>

int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    std::vector<int> arr = {10, 7, 8, 9, 1, 5};
    int arr_size = arr.size();

    std::cout << "Given array is \n";
    for (int i = 0; i < arr_size; i++)
        std::cout << arr[i] << " ";

    quickSort(arr, 0, arr_size - 1);

    std::cout << "\nSorted array is \n";
    for (int i = 0; i < arr_size; i++)
        std::cout << arr[i] << " ";

    return 0;
}

```





### 6 第K大数用快排做



```c++
#include <iostream>
#include <vector>

int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] >= pivot) {
            i++;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return (i + 1);
}

int findKthLargest(std::vector<int>& arr, int low, int high, int k) {
    if (k > 0 && k <= high - low + 1) {
        int pi = partition(arr, low, high);

        if (pi - low == k - 1)
            return arr[pi];
        if (pi - low > k - 1)
            return findKthLargest(arr, low, pi - 1, k);

        return findKthLargest(arr, pi + 1, high, k - pi + low - 1);
    }

    return -1; // Return a value indicating that the value of k is out of bounds
}

int main() {
    std::vector<int> arr = {12, 3, 5, 7, 4, 19, 26};
    int arr_size = arr.size();
    int k = 3; // Example: Find the 3rd largest element

    std::cout << "Given array is \n";
    for (int i = 0; i < arr_size; i++)
        std::cout << arr[i] << " ";

    int kthLargest = findKthLargest(arr, 0, arr_size - 1, k);

    if (kthLargest != -1)
        std::cout << "\nThe " << k << "th largest element is " << kthLargest;
    else
        std::cout << "\nInvalid value of k";

    return 0;
}

```


### 7.矩阵快速幂解决一维递推优化，矩阵快速幂求数列第n项，求前n项和（PPT-7）



```c++

```




### 8.逆序对



```c++
#include <iostream>
#include <vector>

long long mergeAndCount(std::vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    std::vector<int> L(n1), R(n2);

    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    long long invCount = 0;
    int i = 0, j = 0, k = left;

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
            invCount += (mid - i + 1);
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }

    return invCount;
}

long long mergeSortAndCount(std::vector<int>& arr, int left, int right) {
    long long invCount = 0;

    if (left < right) {
        int mid = left + (right - left) / 2;

        invCount += mergeSortAndCount(arr, left, mid);
        invCount += mergeSortAndCount(arr, mid + 1, right);
        invCount += mergeAndCount(arr, left, mid, right);
    }

    return invCount;
}

int main() {
    std::vector<int> arr = {1, 20, 6, 4, 5};
    int arr_size = arr.size();

    std::cout << "Given array is \n";
    for (int i = 0; i < arr_size; i++)
        std::cout << arr[i] << " ";

    long long invCount = mergeSortAndCount(arr, 0, arr_size - 1);

    std::cout << "\nNumber of inversions are " << invCount;

    return 0;
}

```



### 9.主定理



```
T(n) = aT (n/b ) + f(n^d)
当使用树来解释递归关系时，我们可以将每个
节点表示为问题的规模，
边表示递归调用，
节点的分支表示每个递归调用生成的子问题数。在这个上下文中：

a 分支的数量，表示每个原问题分解成多少个子问题,递归调用的子问题数
b 是问题规模相对于每个子问题规模的缩小比例，表示每个子问题的规模相对于原问题的缩小程度。
d:代表一次治的时间复杂度，比如遍历一次就是( n^1)

主定理，d与logba去对比
logbn是树高


若 d > logb a，T(n) = O(n^d)

若 d = logb a，T(n) = O(n^d log n)

若 d < logb a，T(n) = O(n^（logb a）)

```




### 10.strassen矩阵乘法

这里简要说明Strassen算法的

1.**将输入矩阵划分为四个子矩阵**

2.**计算七个子问题：**

3.**计算结果矩阵的四个部分：**

*T*(*n*) = 7*T*( *n* /2 ) + *O*(*n*^2) = *O*(*n*^（log2 -7）) = *O*(*n*2*.*81)



Strassen算法通过减少矩阵乘法的次数来提高效率。虽然它在理论上具有更好的时间复杂度，但实际上由于常数因子较大，对于小规模问题可能不如经典的矩阵乘法算法。通常，在较大的矩阵规模下，Strassen算法的优势才会显现出来。



### 11插值.



**点值表示--->插值表示**

条件：有一条函数曲线，有两个点x0,x1和他们的f(x0),f(x1)，取一条直线逼近曲线，这是插值

（梯形法是一次插值，但是近似程度不够）



**插值** **(interpolation)** **拉格朗日插值多项式** 

*n* + 1 不同的点 (*x**i**, y**i***)，可确定 *n* 阶多项式函数的**全部系数**



**优化一：辛普森积分法**

利用，a,b,(a+b)/2 三个点

进阶：梯形近似法







将区间等分n份，该如何如何分配位置，是否等分n？

**引出优化二：自适应辛普森算法**

分配n个点的位置，使分解后结果使得积分值在误差范围内



### 12 多项式表示法转换

###  ( 系数表示法 / 点值表示法 )

**系数表示法：**
A(x)= *a*0 + *a*1*x* + *a*2*x*^2 + *···* + *a**n** x^n*

系数表示法就是一个向量(a0,a1,a2,a3,a4.......an)



*加法时间复杂度 O(n), 乘法时间复杂度 **O(n2)***



**点值表示法：**
n个离散的点

（x0,f(x0)）（x1,f(x1)）（x2,f(x2)）（x3,f(x3)）（x4,f(x4)）



*加法时间复杂度 O(n), 乘法时间复杂度 **O(n)***



**互相转换：**



**PPT--P47**
见笔记吧





### 13快速傅里叶变换.

见笔记吧








### 11插值.



```c++

```



### 11插值.



```c++

```







## 算法-上课(低优先级)

### 1.编辑距离
```题目描述：
题目来源

题目描述

辅助：

```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.dp数组的边界
5.遍历顺序
6.打印dp数组
```



```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

```


### 2.快乐聚会(大概率不考，是个树的问题)
```题目描述：
题目来源

题目描述

辅助：

```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.dp数组的边界
5.遍历顺序
6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

```


## leetcode题目解析

### 1-509.斐波那契数

```题目描述：
题目来源
https://leetcode.cn/problems/fibonacci-number/description/
题目描述
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。


辅助：

```

```
1.dp数组以及下标的含义
下标为i时的斐波那契数的值

2.递推公式
F(n) = F(n - 1) + F(n - 2)

3.dp数组如何初始化

F(0)=0,F(1)=1
4.dp数组的边界
dp_n<=n
5.遍历顺序
从2到n
6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
using namespace std;
#include<vector>

class Solution {
public:
    int fib(int n) {
        if (n == 0)
        {
            return 0;
        }
        else if (n == 1)
        {
            return 1;
        }
        else
        {
            vector<int> dp(n+1);
            dp[0] = 0;
            dp[1] = 1;
            for (int i = 2; i <= n; i++)
            {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];

        }

    }
};


int main()
{

    Solution sol;
    cout << sol.fib(3) << endl;

}
```

### 2-70.爬楼梯


```题目描述：
题目来源
https://leetcode.cn/problems/climbing-stairs/
题目描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

辅助：
```

```
1.dp数组以及下标的含义
下标为i表示爬到第i阶楼梯的方法数

2.递推公式

dp[i]=dp[i-1]+dp[i-2]
3.dp数组如何初始化
dp[0]=1
dp[1]=1
dp[2]=2

4.dp数组的边界
dp_n=n

5.遍历顺序
从i=2开始到n

6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
using namespace std;
#include<vector>

class Solution {
public:
    int climbStairs(int n) {
        if (n == 1)
        {
            return 1;
        }
        else
        {
            vector<int> dp(n + 1);
            dp[0] = 1;
            dp[1] = 1;
            for (int i = 2; i <= n; i++)
            {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];
        }
    }
};



int main()
{
    Solution sol;
    cout << sol.climbStairs(3) << endl;


}
```


### 3-746.使用最小花费爬楼梯

```题目描述：
题目来源
https://leetcode.cn/problems/min-cost-climbing-stairs/description/
题目描述
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

辅助：
```

```
1.dp数组以及下标的含义
下标i表示爬到第i阶楼梯的最小花费
2.递推公式

dp[i]+=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])

3.dp数组如何初始化
dp[0]=0
dp[1]=0
dp[2]=min(cost[0],cost[1])


4.dp数组的边界
dp_n到n

5.遍历顺序
i=2到n

6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
    这道题的状态转移公式一开始写错了
    一开始写的是dp[i]=min(dp[i-1],dp[i-2])
    但是我也在想，那cost[i]在哪里加进去
    于是后来就改正了状态转移公式：
    dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])

2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

#include<iostream>
using namespace std;
#include<vector>



class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int len = cost.size();
        vector<int> dp(len+1,0);

        for (int i = 2; i <= len; i++)
        {
            		dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[len];


    }
};



int main()
{

    Solution sol;
    vector<int> a = {1,2,3};

    cout<<sol.minCostClimbingStairs(a)<<endl;


}

```


### 4-62.不同路径

```题目描述：
题目来源
https://leetcode.cn/problems/unique-paths/description/
题目描述
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

辅助：

```

```
1.dp数组以及下标的含义
dp[i][j]，下表i，j表示走到该点的路径数

2.递推公式

dp[i][j]=dp[i][j-1]+dp[i-1][j]

3.dp数组如何初始化
第一行和第一列都是1


4.dp数组的边界



5.遍历顺序

从左到右，从上到下

6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

#include<iostream>
using namespace std;
#include<vector>

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));
        for (int i = 0; i < m; i++)
        {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++)
        {
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j < n; j++)
            {
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
            }
        }

        return dp[m - 1][n - 1];
    }
};


int main()
{
    Solution sol;
    cout<<sol.uniquePaths(3,7)<<endl;

}
```



### 5-63.不同路径 II


```题目描述：
题目来源
https://leetcode.cn/problems/unique-paths-ii/description/
题目描述
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。
辅助：

```

```
1.dp数组以及下标的含义
下标i,j表示走到当前位置所需的路径数

2.递推公式
if(obstacleGrid==1)
    continue
else
    dp[i][j]=dp[i][j-1]+dp[i-1][j];
3.dp数组如何初始化
    第一行直到遇到第一个阻塞点之前都是1
    第一列直到遇到第一个阻塞点之前都是1
    初始化全为0
4.dp数组的边界
    dp_m=m
    dp_n=n
5.遍历顺序
    从左到右
    从上到下
6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

#include<iostream>
using namespace std;
#include<vector>

class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();//行
		int n = obstacleGrid[0].size();//列
		vector<vector<int>> dp(m, vector<int>(n, 0));
		for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
		for (int i = 0; i < n && obstacleGrid[0][i] == 0; i++) dp[0][i] = 1;

		for(int i=1;i<m;i++)
			for (int j = 1; j < n; j++)
			{
				if (obstacleGrid[i][j] == 1)
				{
					continue;
				}
				else
					dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}

		return dp[m - 1][n - 1];
    }
};


int main()
{
    Solution s;
	vector<vector<int>> obstacleGrid = { {0,0,0},{0,1,0},{0,0,0} };
	cout << s.uniquePathsWithObstacles(obstacleGrid) << endl;
	return 0;


}
```




### 6-343.整数拆分
```题目描述：
题目来源
https://leetcode.cn/problems/integer-break/description/
题目描述
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。
辅助：

```

```
1.dp数组以及下标的含义
下标为i的数的最大乘积
2.递推公式
 dp[i] = max(dp[i], max(j * i - j, j * dp[i - j]))


3.dp数组如何初始化
dp[0]=0
dp[1]=0
dp[2]=2


4.dp数组的边界
dp_i=n
j从1到i

5.遍历顺序
i从2到n
j从1到i

6.打印dp数组
n=2,1
n=3,2
n=4,4
n=5,6
n=6,9
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
状态转移公式一开始写错了

2. 我打印dp数组的⽇志了么？
这道题我打印了，一个一个看的，犯的错误是i一开始写的是<n,应该是<=n

3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
using namespace std;
#include<vector>





class Solution {
public:
    int integerBreak(int n) {

        vector<int> dp(n + 1, 0);

        for (int i = 2; i <= n; i++)
        {
            for (int j = 1; j < i; j++)
            {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }

        return dp[n];
    }
};



int main()
{
    Solution sol;
    cout<< sol.integerBreak(5) << endl;


}
```


### 7-96.不同的二叉搜索树

```题目描述：
题目来源
https://leetcode.cn/problems/unique-binary-search-trees/description/
题目描述
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
辅助：

```

```
1.dp数组以及下标的含义
下标为i的数的二叉搜索树的种数

2.递推公式

dp[i]+=dp[j-1]*dp[i-j]

3.dp数组如何初始化
所有为0，后面的都是由前面的推导出来的
dp[0]=1
dp[1]=1


4.dp数组的边界
从1到n

5.遍历顺序
i从2到n
j从1到i
6.打印dp数组

n=1,1
n=3.5


```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;



class Solution {
public:
    int numTrees(int n) {
		vector<int> dp(n + 1, 0);
		dp[0] = 1;
		dp[1] = 1;
		for (int i = 2; i <= n; i++)
		{
			for (int j = 1; j <= i; j++)
			{
				dp[i]+= dp[j - 1] * dp[i - j];
			}
		}

		return dp[n];
    }
};


int main() {
	Solution s;
	cout << s.numTrees(3) << endl;
	return 0;
}
```

### 8-01背包问题



```题目描述：
题目来源
无
题目描述
有n件物品和⼀个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能
⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。
辅助：
https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.788&vd_source=b0ad7a11a35f6bb99c79b79b455563fa
```

```
1.dp数组以及下标的含义
dp[i][j]
i:表示前i个物品
j:表示背包此刻还能装的重量有多少
dp[i][j]表示前i个物品，背包此刻还能装的重量有j时，背包中物品的最大价值

2.递推公式
第i个物品不装进背包：
dp[i][j]=dp[i-1][j]
第i个物品装进背包：
dp[i][j]=dp[i-1][j-weight[i]]+value[i]

dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])

3.dp数组如何初始化
二维数组，第一行逐个检查，第一列因为j=0，所以都是0
剩下的行不用管，因为剩下的都是由前面的推导出来的，都会被覆盖

4.dp数组的边界
0-n-1

5.遍历顺序

先i，再j
也可以
先j，再i
实现两个版本

6.打印dp数组
```


```
出错原因：灵魂三问：
问题1
这道题给的bagWeight是w
我初始化的时候size应该申请w+1个空间！！！
问题2
在给第一行初始化的时候，我一开始写的是
	for (int i = 0; i < w; i++)
	{
		if (weight[0] < i)
		{
			dp[0][i] = value[0];

		}
		else
		{
			dp[0][i] = 0;
		}
	}	
正确的是
	for (int i = 0; i < w; i++)
	{
		if (weight[0] <= i)#区别在于我是在等于的时候，物品0是可以装入背包的
		{
			dp[0][i] = value[0];

		}
		else
		{
			dp[0][i] = 0;
		}
	}	



1. 这道题⽬我举例推导状态转移公式了么？
问题三：
状态转移公式没有考虑，遍历背包容量时，weight[i]大于当前背包容量的情况
缺了下面这行代码
		if (weight[i] > j)
			{
				dp[i][j] = dp[i - 1][j];
			}

换个角度考虑，状态转移公式：
dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
第二个逗号的j-weight[i]是有可能小于0的，所以要加上上面的判断



2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

int main() {
	
	int w = 6;
	int weight[5] = { 2,2,3,1,5 };
	int n=sizeof(weight)/sizeof(weight[0]);
	int value[5] = { 2,3,1,5,4 };


	vector<vector<int>> dp(n, vector<int>(w+1, 0));

	for (int i = 0; i < w; i++)
	{
		if (weight[0] <= i)
		{
			dp[0][i] = value[0];

		}
		else
		{
			dp[0][i] = 0;
		}
	}	

	for (int i = 0; i < n; i++)
	{
		dp[i][0]=0;
	}
	int maxNum = 0;
	for (int i = 1; i < n;i++)
	{
		for (int j = 0; j < w; j++)
		{


			if (weight[i] > j)
			{
				dp[i][j] = dp[i - 1][j];
			}
			else
			{ 
			dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
			
			
			}
			if (dp[i][j]>maxNum)
			{
				maxNum=dp[i][j];
			}
		
		}
	}

	cout<<maxNum<<endl;

}	


```

### 9-01背包问题-滚动数组优化
```题目描述：
题目来源

题目描述
滚动数组，就是把⼆维dp降为⼀维dp

辅助：
```

```
1.dp数组以及下标的含义

dp[j]:
长度为j的背包，能装的最大价值

2.递推公式
dp[j]=max(dp[j],dp[j-weight[i]]+value[i])

3.dp数组如何初始化
初始全为0

4.dp数组的边界
物品从 i=0,到i<weight.size()
背包容量 从 j=bagSize,到 j>=weight[i],

5.遍历顺序
背包容量从后向前遍历
为什么不是从前向后遍历
因为递推公式：dp[j]=max(dp[j],dp[j-weight[i]]+value[i])
dp[j-weight[i]]+value[i],依赖dp[j-weight[i]],如果从前向后遍历，先计算的j会污染后面的值计算。
只有从后向前遍历，才能保证每个物品只放一次

举例：
如果正序遍历
dp[1] = dp[1 - weight[0]] + value[0] = 15
dp[2] = dp[2 - weight[0]] + value[0] = 30
此时dp[2]就已经是30了，意味着物品0，被放⼊了两次，所以不能正序遍历。
为什么倒序遍历，就可以保证物品只放⼊⼀次呢？
倒序就是先算dp[2]
dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）
dp[1] = dp[1 - weight[0]] + value[0] = 15
所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取⼀次了。




6.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
//#include<iostream>
//using namespace std;
//#include<vector>
//
//
//int main()
//{
//	vector<int> weight = {1,2,3,2,1};
//	vector<int> value = { 1,2,3,1,2 };
//	int bagSize = 7;
//
//	vector<int> dp(bagSize + 1, 0);
//
//	for (int i = 0; i < weight.size(); i++)
//	{
//		for (int j = bagSize; j >= weight[i]; j--)
//		{
//			dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
//		}
//	}
//
//
//}
```


### 10-01背包问题-灵魂发问

```
出错原因：灵魂三问：
1. 二维数组两个for循环的顺序可以交换么？

2. 实现一维数组版本

3. 一维数组版本两个for循环的顺序可以交换吗

4.for循环为什么是从后向前遍历，为什么不可以从前向后遍历

5.为什么二维数组的遍历顺序可以随便

```



### 11-416.分割等和子集

```题目描述：
题目来源
https://leetcode.cn/problems/partition-equal-subset-sum/
题目描述
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
辅助：

```

```
1.dp数组以及下标的含义
dp[j]

下标j表示容量为j的背包，能加和的总合

2.递推公式
dp[j]=max(dp[j],dp[j-nums[i]]+nums[i])


3.dp数组如何初始化

为0

4.dp数组的边界

5.遍历顺序
从后往前遍历


6.打印dp数组

```


```
出错原因：灵魂三问：
原因一：忘记返回flag了
原因二：当sum%2除不开的时候，结构性就无法获得true了，直接返回false

1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
using namespace std;
#include<vector>


class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
        }
        if (sum % 2 == 1) return false;

        int target = sum / 2;
      
        
        
        bool flag = false; 

        vector<int> dp(target + 1, 0);

        for (int i = 0; i < nums.size(); i++)
        {
            for (int j=target;j>=nums[i] ; j--)
            {
                			dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
                if (dp[j] == target)
                            {
					flag = true;
					break;
				}
            }
        }
        return flag;
    }
};


int main()
{
    vector<int> nums= {1,2,3,5};
    Solution s;
    cout<<s.canPartition(nums)<<endl;


}

```


### 12-1049.最后一块石头的重量 II

```题目描述：
题目来源
https://leetcode.cn/problems/last-stone-weight-ii/description/
题目描述
有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

辅助：
```

```
1.dp数组以及下标的含义
dp[j]
j表示容量为j的石头总和，能得到重量总和

2.递推公式
dp[j]=max(dp[j],dp[j-stones[i]]+stones[i])

3.dp数组如何初始化
全为0

4.dp数组的边界

5.遍历顺序
背包容量从后向前遍历

6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
using namespace std;
#include<vector>

class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (int i = 0; i < stones.size(); i++)
        {
            		sum += stones[i];
        }
        int target= sum / 2;
        vector<int> dp(target + 1, 0);
        for (int i = 0; i < stones.size(); i++)
        {
            for (int j = target; j >= stones[i]; j--)
            {
				dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
			}   
        }
        return (sum-dp[target])-dp[target];


    }
};

```


### 13-494. 目标和

```题目描述：
题目来源
https://leetcode.cn/problems/target-sum/description/
题目描述
给你一个非负整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
辅助：
```

```
1.dp数组以及下标的含义

dp[j]
j表示下标为j的数是目标和,dp[j]表示有多少种方法
2.递推公式
left+right=sum
right=sum-left
left-right=tareget
2left-sum=target
left=(target+sum)/2

dp[j]=dp[j]+dp[j-nums[i]]


3.dp数组如何初始化
第一个数为1，其他为0
4.dp数组的边界

5.遍历顺序
物品i从0到nums.size()
背包容量j从left到nums[i]

6.打印dp数组
```


```
出错原因：灵魂三问：
before:
        if (((sum + target) % 2) == 1)
        {
            return 0;
        }
    
		vector<int> dp(left + 1, 0);
        if (abs(target) > sum)
        {
            return 0;
        }
after
        if (((sum + target) % 2) == 1)
        {
            return 0;
        }
        if (abs(target) > sum)
        {
            return 0;
        }
		vector<int> dp(left + 1, 0);
原因分析：可能是因为我把abs(target) > sum放在了dp数组初始化的后面，导致了数组越界

问题二：
 dp[0] = 1;忘了初始化dp[0]了

1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
#include<vector>
using namespace std;


class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        int left=(sum+target)/2;
        if (((sum + target) % 2) == 1)
        {
            return 0;
        }
        if (abs(target) > sum)
        {
            return 0;
        }
		vector<int> dp(left + 1, 0);

        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++)
        {
            for (int j = left; j >= nums[i]; j--)
            {
                dp[j] += dp[j - nums[i]];
            }
        }

        return dp[left];
        
    }
};

```


### (未做)14-474. 一和零
```题目描述：
题目来源
https://leetcode.cn/problems/ones-and-zeroes/description/
题目描述
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 
辅助：
```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.dp数组的边界
5.遍历顺序
6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

```


### 15-完全背包
```题目描述：
题目来源

题目描述
有N件物品和⼀个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有
⽆限个（也就是可以放⼊背包多次），求解将哪些物品装⼊背包⾥物品价值总和最⼤。
辅助：

```

```
1.dp数组以及下标的含义
dp[j]
j表示背包容量为j时，背包中物品的最大价值
2.递推公式
dp[j]=max(dp[j],dp[j-weight[i]]+value[i])

3.dp数组如何初始化
全为0
4.dp数组的边界
5.遍历顺序
先遍历背包再遍历物品也行
先遍历物品再遍历背包也行
但是遍历背包必须从前往后遍历

6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

//先遍历物品，再遍历背包
void test_CompletePack_1() {
	vector<int> weight = { 1, 3, 4 };
	vector<int> value = { 15, 20, 30 };
	int bagWeight = 4;

	vector<int> dp(weight.size() + 1, 0);

	for (int i = 0; i < weight.size(); ++i)
	{
		for (int j = weight[i]; j <= bagWeight; ++j)
		{
			dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
		}
	}

	cout<<dp[bagWeight]<<endl;
}


//先遍历背包，再遍历物品
void test_CompletePack_2() {
	vector<int> weight = { 1, 3, 4 };
	vector<int> value = { 15, 20, 30 };
	int bagWeight = 4;

	vector<int> dp(bagWeight + 1, 0);

	for (int j = 0; j < bagWeight; ++j)
	{
		for (int i = 0; i < weight.size(); ++i)
		{
			if (j >= weight[i])
			{
				dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
			}
			
		}
	}

	cout << dp[bagWeight] << endl;

}
```




### 16-518. 零钱兑换 II


```题目描述：
题目来源
https://leetcode.cn/problems/coin-change-ii/description/
题目描述
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
假设每一种面额的硬币有无限个。 
题目数据保证结果符合 32 位带符号整数。
辅助：
```

```
1.dp数组以及下标的含义
dp[j]
j表示金钱总和为j时，dp[j]表示多少种方法

2.递推公式
dp[j]+=dp[j-coins[i]]

3.dp数组如何初始化
dp[0]=1
其余为0


4.dp数组的边界

5.遍历顺序
因为是组合，前后顺序无所谓
所以先遍历物品，再遍历背包
因为可以重复拿取，所以是从前往后遍历背包

6.打印dp数组
```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？

2. 我打印dp数组的⽇志了么？

3. 打印出来了dp数组和我想的⼀样么？

```

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++)
        {
            for (int j = coins[i]; j <= amount; j++)
            {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];

    }
};
```

### 17-377. 组合总和 Ⅳ
```题目描述：
题目来源
https://leetcode.cn/problems/combination-sum-iv/description/
题目描述
给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
辅助：
```

```
1.dp数组以及下标的含义
dp[j]
j表示数和，dp[j]表示值为j的数和，有多少种组合

2.递推公式

dp[j]+=dp[j-nums[i]]

3.dp数组如何初始化
dp[0]=1
其余为0

4.dp数组的边界

5.遍历顺序
完全背包，背包遍历顺序是从前往后遍历
先外层遍历背部，再遍历物品，因为是不同的整数数组，顺序不同算作两个数组，所以是排列问题


6.打印dp数组
```


```
出错原因：灵魂三问：
错误原因：
//        for (int j = 0; j <= target; j++)
//        {
//            for (int i = 0; i < nums.size(); i++)
第一个外层循环，我没有写j<=target,我写的是j<target
这样写应该会导致dp[target]没有被赋值，所以一直是0



1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target+1,0);
        dp[0]=1;

        for (int j = 0; j <= target; j++)
        {
            for (int i = 0; i < nums.size(); i++)
            {
                if (nums[i] <= j && dp[j] < INT_MAX - dp[j - nums[i]])
                {
					dp[j]+=dp[j-nums[i]];
				}
            }
        }

        return dp[target];

    }
};

```



### 18-70. 爬楼梯
```题目描述：
题目来源
https://leetcode.cn/problems/climbing-stairs/description/
题目描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
辅助：
```

```
1.dp数组以及下标的含义
dp[j]
j为高度，dp[j]表示高度为j的楼梯有多少种方法
2.递推公式
dp[j]+=dp[j-nums[i]]

3.dp数组如何初始化
dp[1]=0,其他为0

4.dp数组的边界

5.遍历顺序
完全背包，背包从前向后遍历
因为求排列
所以外层先遍历背包，内层再遍历物品

6.打印dp数组
```


```
出错原因：灵魂三问：
错误原因
                if (nums[i] <= j)
                {
                    dp[j] += dp[j - nums[i]];
                }
忘记加if条件判断了，if nums[i]>j,会数组越界

1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++



class Solution {
public:
    int climbStairs(int n) {
        vector<int> nums{ 1,2 };
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int j = 0; j <= n; j++)
        {
            for (int i = 0; i < nums.size(); i++)
            {
                if (nums[i] <= j)
                {
                    dp[j] += dp[j - nums[i]];
                }
               
            }
        }
        return dp[n];

    }
};
```


### 19-322. 零钱兑换

```题目描述：
题目来源
https://leetcode.cn/problems/coin-change/description/
题目描述
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
辅助：
```

```
1.dp数组以及下标的含义
dp[j]
j表示总金额为j时，dp[j]表示最少的硬币个数
2.递推公式
dp[j]=min( dp[j] , dp[j-coins[i]]+1 )

3.dp数组如何初始化
第一个dp[0]=0
其他为INT_MAX

4.dp数组的边界

5.遍历顺序
因为为最少，其实背包和物品的遍历顺序无所谓
但因为完全背包，所以背包从前向后遍历
6.打印dp数组
```


```
出错原因：灵魂三问：

            for (int j = coins[i]; j <= amount; ++j)
            {
                if (dp[j - coins[i]] != INT_MAX)
                dp[j] = min(dp[j], dp[j - coins[i]] + 1);
            }
如果不加 if (dp[j - coins[i]] != INT_MAX)，在第一遍遍历的时候，会有dp[j]=min(INT_MAX,INT_MAX)这种情况，然后再+1，就变成了负数
，导致错误

1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
using namespace std;
#include<vector>


class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); ++i)
        {
            for (int j = coins[i]; j <= amount; ++j)
            {
                if (dp[j - coins[i]] != INT_MAX)
                dp[j] = min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        if (dp[amount] == INT_MAX)
			return -1;
        else
            return dp[amount];


    }
};


int main()
{

    vector<int> coins{ 2 };
    int amount = 3;
    Solution a;
    int ret = a.coinChange(coins, amount);

}
```


### 20-279. 完全平方数

```题目描述：
题目来源
https://leetcode.cn/problems/perfect-squares/description/
题目描述
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
辅助：
```

```
1.dp数组以及下标的含义
dp[j]
j表示当前的平方和，dp[j]表示组成当前的平方和的最少数量

2.递推公式

dp[j]=min(dp[j],dp[j-i*i]+1)

3.dp数组如何初始化
dp[0]=0
其他为INT_MAX

4.dp数组的边界

5.遍历顺序
先遍历背包还是先遍历物品都可以
但是因为是完全背包，所以，背包从前向后遍历

6.打印dp数组
```


```
出错原因：灵魂三问：
            for (int i = 1; i*i <= n; i++)
            {
                for (int j =i*i ; j<=n; j++)
一开始外层循环我只写的是i*i<n ,但是当n=1时，这么写跑不通了，应该是i*i<=n


1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
using namespace std;
#include<vector>




class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
            for (int i = 1; i*i <= n; i++)
            {
                for (int j =i*i ; j<=n; j++)
                {
                    dp[j] = min(dp[j], dp[j - i * i] + 1);
                }
            }


            return dp[n];
    }
};

int main()
{
    Solution s;
    int ret=s.numSquares(1);

}
```


### (难)21-139. 单词拆分

```题目描述：
题目来源
https://leetcode.cn/problems/word-break/description/
题目描述
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
辅助：
```

```
1.dp数组以及下标的含义
dp[i]
j<i
i表示字符串的下标，dp[i]表示字符串是否可以被拆分


2.递推公式

if(dict.find(str(i-j))!=dict.end&&dp[j]==true)
    dp[i]=true



3.dp数组如何初始化
dp[0]=true
其他全为false


4.dp数组的边界

5.遍历顺序
先遍历背包，再遍历物品
完全背包，从前向后遍历背包

6.打印dp数组
```


```
出错原因：灵魂三问：
问题1：unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
没有把单词放到set里
问题2：  string tmpWord = s.substr(j, i-j);
string的substr方法使用不熟练
问题3： for (int i = 0; i <= len_s; i++)
一开始没有写等于号，导致字符串最后一个字符没有被判断



1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        
        
        int len_s = s.size();
        vector<bool> dp(len_s + 1, false);  
        dp[0] = true;
        for (int i = 0; i <= len_s; i++)
        {
            for (int j = 0; j < i; j++)
            {
                string tmpWord = s.substr(j, i-j);
                if (wordSet.find(tmpWord) != wordSet.end() && dp[j] == true)
                {
                    dp[i] = true;
                }
            }
        }
        return dp[len_s];
    }
};
```


### 22-198. 打家劫舍

```题目描述：
题目来源
https://leetcode.cn/problems/house-robber/description/

题目描述
你是一个专业的小偷，计划偷窃沿街的房屋。
每间房内都藏有一定的现金，
影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 
，一夜之内能够偷窃到的最高金额。

辅助：
```

```
1.dp数组以及下标的含义
dp[i]
i表示房屋的下标，dp[i]表示偷到第i个房屋的最大金额

2.递推公式
dp[i]=max(dp[i-1],dp[i-2]+value[i])

3.dp数组如何初始化
dp[0]=value[0]
dp[1]=value[1]


4.dp数组的边界

5.遍历顺序
从i=2开始遍历
遍历到i=nums.size()-1

6.打印dp数组
```


```
出错原因：灵魂三问：

问题1：  if (len == 1)  else if(len==2)
没有考虑到只有一个房屋和两个房屋的情况
问题2:            for (int i = 2; i < len; i++)
            {
                dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
            }
没有思考清除i<len还是i<=len,但其实很好理解应该是i<len,因为当i=len时，nums[i]根本取不到数，数组会越界
问题3：     return dp[len - 1];
一开始写的是return dp[len]，但其实dp[len]=0

            




1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int len = nums.size();

        vector<int> dp(len + 1, 0);

        dp[0] = nums[0];
        if (len == 1)
        {
			return dp[0];
		}
        else if(len==2)
        {
            if (nums[1] > nums[0])
            {
                dp[1] = nums[1];
            }
            else
            {
                dp[1] = nums[0];
            }
            return max(dp[0], dp[1]);

        }
        else
        {
            if (nums[1] > nums[0])
            {
                dp[1] = nums[1];
            }
            else
            {
                dp[1] = nums[0];
            }
            for (int i = 2; i < len; i++)
            {
                dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
            }
            return dp[len - 1];
        }

    }
};


```



### 23-213. 打家劫舍 II

```题目描述：
题目来源
https://leetcode.cn/problems/house-robber-ii/description/
题目描述
你是一个专业的小偷，
计划偷窃沿街的房屋，
每间房内都藏有一定的现金。
这个地方所有的房屋都 围成一圈 ，
这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
辅助：
```

```
1.dp数组以及下标的含义
dp[i]，表示在第i个房屋的最大金额

2.递推公式

1 2 3 4 5
a:2 3 4 5
b:1 2 3 4
c:2 3 4
ret=max(f(a),f(b),f(c))

f: dp[i]=max(dp[i-1],dp[i-2]+nums[i])


3.dp数组如何初始化

dp[0]=nums[0]
dp[1]=nums[2]   

4.遍历顺序

    4.1等号要不要带上
    不带    
    4.2for循环的起点，终点
    从i=2开始，到i<nums.size()结束
5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:

    int rob0(vector<int>& nums) {
        int len = nums.size();

        vector<int> dp(len + 1, 0);

        dp[0] = nums[0];
        if (len == 1)
        {
            return dp[0];
        }
        else if (len == 2)
        {
            if (nums[1] > nums[0])
            {
                dp[1] = nums[1];
            }
            else
            {
                dp[1] = nums[0];
            }
            return max(dp[0], dp[1]);

        }
        else
        {
            if (nums[1] > nums[0])
            {
                dp[1] = nums[1];
            }
            else
            {
                dp[1] = nums[0];
            }
            for (int i = 2; i < len; i++)
            {
                dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
            }
            return dp[len - 1];
        }

    }


    int rob(vector<int>& nums) {
        int len = nums.size();
        vector<int> dp(len + 1, 0);
        dp[0] = nums[0];
        if (len == 1)
        {
            return dp[0];
        }
        else if (len == 2)
        {
            return max(nums[0], nums[1]);

        }

        vector<int> num1(nums.begin(), nums.end() - 1);
        vector<int> num2(nums.begin() + 1, nums.end());
        int ret = max(rob0(num1), rob0(num2));
        return ret;
    }
};
```

### 24(不会：树)-337. 打家劫舍 III

```题目描述：
题目来源
https://leetcode.cn/problems/house-robber-iii/description/
题目描述
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

辅助：
```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.遍历顺序

    4.1等号要不要带上
    
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

```

### 25-121. 买卖股票的最佳时机

```题目描述：
题目来源
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/
题目描述
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，
并选择在 未来的某一个不同的日子 卖出该股票。
设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 
辅助：
```

```
1.dp数组以及下标的含义
dp[i][0/1]

i表示第i天，0表示此时不持有股票，1表示此时持有股票，dp[i][0/1]表示第i天不持有/持有股票时的最大利润
2.递推公式
              dp[i][0] = max((dp[i - 1][0]), (dp[i - 1][1] + prices[i]));
              dp[i][1] = max(-prices[i],dp[i-1][1]);

3.dp数组如何初始化
          dp[0][0]=0;
          dp[0][1]=-prices[0];
4.遍历顺序
i从=1开始到size()
    4.1等号要不要带上
    不带
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len=prices.size();
        vector<vector<int>> dp(len + 1, vector<int>(2,0));

         //0表示此时不持有股票，1表示此时持有股票
          dp[0][0]=0;
          dp[0][1]=-prices[0];

          int maxN = 0;
          for (int i = 1; i < len; i++)
          {
              dp[i][0] = max((dp[i - 1][0]), (dp[i - 1][1] + prices[i]));
              dp[i][1] = max(-prices[i],dp[i-1][1]);
              
              int ret = max(dp[i][0], dp[i][1]);
              if (ret>maxN)
              {
				  maxN=ret;
			  }

          }
          return maxN;
    }
};

```


### 26-122. 买卖股票的最佳时机 II

```题目描述：
题目来源
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/
题目描述
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润 。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][0/1]
i表示第i天，0表示此时不持有股票，1表示此时持有股票，dp[i][0/1]表示第i天不持有/持有股票时的最大利润
2.递推公式
dp[i][0]=max(dp[i-1][0],dp[i-1][1]+nums[i])
dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1])
3.dp数组如何初始化
dp[0][0]=0
dp[0][1]=-prices[i]
4.遍历顺序
从i=1到size()
    4.1等号要不要带上
    不带
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size() + 1, vector<int>(2, 0));
        dp[0][1] = -prices[0];
        dp[0][0]= 0;
        int maxN = 0;
        for (int i = 1; i < prices.size(); ++i)
        {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);

            int tmp = max(dp[i][0], dp[i][1]);
            if (tmp > maxN)
            {
				maxN = tmp;
			}

            
        }

        return maxN;





    }
};
```




### 27-123. 买卖股票的最佳时机 III

```题目描述：
题目来源
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/
题目描述
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][1/2/3/4]
i:表示第i天
0.初始什么都不买状态
1. 第一只股票是买入状态
2. 第一只股票是不买入状态
3. 第⼆次持有股票
4. 第⼆次不持有股票


2.递推公式

dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
dp[i][2]=max(dp[i-1][2],dp[i-1][1]+prices[i]);
dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i]);
dp[i][4]=max(dp[i-1][4],dp[i-1][3]+prices[i]);



3.dp数组如何初始化
dp[][0]=0
dp[][1]=-prices[0]
dp[][2]=0
dp[][3]=-prices[0]
dp[][4]=0



4.遍历顺序
 从i=1到size（）
    4.1等号要不要带上
    不带
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
我写了一个maxN=0，然后让for循环里的所有数与maxN比较大小赋值
其实不用，直接返回最后一个数的[4]就可以了




1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));

        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        for (int i = 1; i < prices.size(); ++i)
        {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return  dp[prices.size() - 1][4];

    }
};
```


### 28-188. 买卖股票的最佳时机 IV

```题目描述：
题目来源
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/
题目描述
给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][2*k+1]
i表示第i天，

0初始什么都不买状态
奇数表示持有股票，偶数表示不持有股票

2.递推公式
                    if (j % 2 == 1)
                    {
                        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j-1] - prices[i]);
                       
                    }
                    else if(j%2==0)
                    {
                        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j-1] + prices[i]);
                    }
3.dp数组如何初始化
            for (int i = 1; i <2* k; i+=2)
            {
                  dp[0][i]=-prices[0];
            }

4.遍历顺序
从i=1到prices.size()
    4.1等号要不要带上
    从j=1到j<=2*k
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
所有的k都忘记了乘以2去做范围遍历



1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
#include<iostream>
#include<vector>
using namespace std;



class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
            vector<vector<int>> dp(prices.size() + 1, vector<int>((2*k) + 1, 0));
            for (int i = 1; i <2* k; i+=2)
            {
                  dp[0][i]=-prices[0];
            }

            for (int i = 1; i < prices.size(); i++)
            {
                dp[i][0] = dp[i-1][0];
                for (int j = 1; j <= 2 * k; j++)
                {
                    if (j % 2 == 1)
                    {
                        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j-1] - prices[i]);
                       
                    }
                    else if(j%2==0)
                    {
                        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j-1] + prices[i]);
                    }
                }
            }

            return dp[prices.size() - 1][2*k];


    }
};


```

### 29-309. 买卖股票的最佳时机含冷冻期

```题目描述：
题目来源
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
题目描述
给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][0/1/2/3]
i表示第i天，
0.初始持有
1.表示不持有
2.今天卖出
3.冷冻期

2.递推公式
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3]-prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2]= dp[i-1][0]+prices[i];
            dp[i][3]= dp[i - 1][2];


3.dp数组如何初始化
        dp[0][0] = -prices[0];   //持有
        dp[0][1] = 0;   //不持有
        dp[0][2] = 0;   //今天卖出
        dp[0][3] = 0; //冷冻期
4.遍历顺序
 i = 1; i < prices.size();
    4.1等号要不要带上
    不带
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
        dp[0][0] = -prices[0];   //持有
        dp[0][1] = 0;   //不持有
        dp[0][2] = 0;   //今天卖出
        dp[0][3] = 0; //冷冻期

        for (int i = 1; i < prices.size(); ++i)
        {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3]-prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2]= dp[i-1][0]+prices[i];
            dp[i][3]= dp[i - 1][2];

        }

        return max(dp[prices.size()-1][1],max(dp[prices.size()-1][2],dp[prices.size()-1][3]));
    }
};
```




### 30-714. 买卖股票的最佳时机含手续费

```题目描述：
题目来源
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/
题目描述
给定一个整数数组 prices，
其中 prices[i]表示第 i 天的股票价格 ；
整数 fee 代表了交易股票的手续费用。
你可以无限次地完成交易，
但是你每笔交易都需要付手续费。
如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。
注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][0/1]
i表示第i天，
0.初始不持有
1.表示持有


2.递推公式
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0]-prices[i]);
3.dp数组如何初始化
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
4.遍历顺序
    从i=1到size()

    4.1等号要不要带上
    不带
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0]-prices[i]);
        }

        return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);
    }
};
```



### 31-300. 最长递增子序列
```题目描述：
题目来源
https://leetcode.cn/problems/longest-increasing-subsequence/description/
题目描述
给你一个整数数组 nums ，
找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，
删除（或不删除）数组中的元素而不改变其余元素的顺序。
例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

辅助：
```

```
1.dp数组以及下标的含义
dp[i]表示以nums[i]结尾的最长递增子序列的长度
2.递推公式
         for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }

3.dp数组如何初始化
    dp[0]=1
4.遍历顺序
      for (int i = 1; i < l; ++i)
    4.1等号要不要带上
    不带
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
 问题一：
 for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
我一开始没写if (nums[i] > nums[j])

1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++



class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int l = nums.size();
        if (l == 1)
            return 1;
        vector<int> dp(l, 1);
        dp[0] = 1;
        int maxN = 0;
        for (int i = 1; i < l; ++i)
        {
            for (int j = 0; j < i; j++)
            {
                if (nums[i] > nums[j])
                {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            if (dp[i] > maxN)
                maxN = dp[i];
        }
        return maxN;
    }
};
```


### 32-674. 最长连续递增序列


```题目描述：
题目来源
https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/
题目描述
给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，
如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，
那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
辅助：
```

```
1.dp数组以及下标的含义

dp[i]表示以nums[i]结尾的最长连续递增子序列的长度

2.递推公式
            if (nums[i] > nums[i - 1])
                dp[i]= dp[i - 1] + 1;
            


3.dp数组如何初始化

全为1

4.遍历顺序
for (int i = 1; i < len; i++)
    4.1等号要不要带上
    不带
    4.2for循环的起点，终点

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int len = nums.size();
        if (len==1) return 1;
        vector<int> dp(len, 1);

        int maxN = 0;
        for (int i = 1; i < len; i++)
        {
            if (nums[i] > nums[i - 1])
            {
                dp[i]= dp[i - 1] + 1;
            
            
            }
            if(dp[i]>maxN) maxN=dp[i];

        }
        return maxN;
    }
};
```


### 33-718. 最长重复子数组
```题目描述：
题目来源
https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/
题目描述
给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i是nums以i-1为结尾的字符串
j是nums2以j-1为结尾的字符串
dp[i][j]是长度

2.递推公式

if nums[i-1]==nums[j-1]
dp[i][j]=dp[i-1][j-1]+1

3.dp数组如何初始化
dp[0][i]=0
dp[j][0]=0
4.遍历顺序
两层for循环，i从1到size，j从1到size
    4.1等号要不要带上
    为什么要带上等于号
    因为看代码：
    for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)
            {
                if (nums1[i - 1] == nums2[j - 1])

    只有带上等于号，nums1[i-1]和nums2[j-1]才能匹配到最后一个字符
    带上！！！
5.打印dp数组

```


```
出错原因：灵魂三问：
        for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)

一开始写成了i<n1,j<n2


1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();

        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
        int maxN = 0;
        for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)
            {
                if (nums1[i - 1] == nums2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    if (dp[i][j] > maxN) maxN = dp[i][j];
                
                }
            }
        }
        return maxN;
    }
};

```


### 34-1143. 最长公共子序列

```题目描述：
题目来源
https://leetcode.cn/problems/longest-common-subsequence/description/
题目描述
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：
它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i是text1以i-1为结尾的字符串
j是text2以j-1为结尾的字符串
dp[i][j]是长度


2.递推公式
                if (text1[i - 1] == text2[j - 1])
                {
					dp[i][j]=dp[i-1][j-1]+1;
				}
				else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);

3.dp数组如何初始化

dp[0][i]=0
dp[j][0]=0
4.遍历顺序
 for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)
    4.1等号要不要带上
    带上

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++




class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1=text1.size();
        int n2=text2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));

        int maxN = 0;
        for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)
            {
                if (text1[i - 1] == text2[j - 1])
                {
					dp[i][j]=dp[i-1][j-1]+1;
				}
				else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
			
                if (dp[i][j] > maxN) maxN = dp[i][j];
            }
		}

        return maxN;

    }
};
```

### 35-1035. 不相交的线
```题目描述：
题目来源
https://leetcode.cn/problems/uncrossed-lines/description/
题目描述
在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
辅助：
```

```
1.dp数组以及下标的含义

2.递推公式
同34
3.dp数组如何初始化

4.遍历顺序


    4.1等号要不要带上
    

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n1=nums1.size();
        int n2=nums2.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));

        int maxN = 0;
        for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)
            {
                if (nums1[i - 1] == nums2[j - 1])
                {
					dp[i][j]=dp[i-1][j-1]+1;
				}
				else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
			
                if (dp[i][j] > maxN) maxN = dp[i][j];
            }
		}

        return maxN;

    }
};
```

### 36-53. 最大子数组和
```题目描述：
题目来源
https://leetcode.cn/problems/maximum-subarray/description/
题目描述
给你一个整数数组 nums ，
请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
辅助：
```

```
1.dp数组以及下标的含义
dp[i]
i表示以i-1为结尾的最大子数组和

2.递推公式
因为要求连续
dp[i] = max(nums[i], dp[i - 1] + nums[i]);

3.dp数组如何初始化
   dp[0]= nums[0];
4.遍历顺序
  for (int i = 1; i < n; ++i)
    4.1等号要不要带上
    不带

5.打印dp数组

```



```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        vector<int> dp(n, 0);
        dp[0]= nums[0];
        int maxN = dp[0];
        for (int i = 1; i < n; ++i)
        {
            dp[i] = max(nums[i], dp[i - 1] + nums[i]);
            if (dp[i] > maxN) maxN = dp[i];
        }

        return maxN;
    }
};
```


### 37-392. 判断子序列
```题目描述：
题目来源
https://leetcode.cn/problems/is-subsequence/description/
题目描述
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）
字符而不改变剩余字符相对位置形成的新字符串。
（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i表示s以i-1为结尾的字符串
j表示t以j-1为结尾的字符串
dp[i][j]是相同的长度

2.递推公式
   if (s[i - 1] == t[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = dp[i ][j-1];
                }

3.dp数组如何初始化
全为0
4.遍历顺序
   for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)
    4.1等号要不要带上
    带上！

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n1=s.size();
        int n2=t.size();
        vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));
        for (int i = 1; i <= n1; i++)
        {
            for (int j = 1; j <= n2; j++)
            {
                if (s[i - 1] == t[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = dp[i ][j-1];
                }


            }
        }


        if (dp[n1][n2]==n1) return true;
		else return false;


    }
};
```


### 38(难)-115. 不同的子序列
```题目描述：
题目来源
https://leetcode.cn/problems/distinct-subsequences/description/
题目描述
给你两个字符串 s 和 t ，
统计并返回在 s 的 子序列 中 t 出现的个数，
结果需要对 109 + 7 取模。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i以字符串s的i-1的位置为结尾
j以字符串t的j-1的位置为结尾
dp[i][j]表示个数
2.递推公式
				if (s[i - 1] == t[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
				}
				else {
					dp[i][j] = dp[i - 1][j];
				}

3.dp数组如何初始化
		for (int i = 0; i < s.size(); i++) dp[i][0] = 1;
		for (int j = 1; j < t.size(); j++) dp[0][j] = 0;

4.遍历顺序

    4.1等号要不要带上
    

5.打印dp数组

```


```
出错原因：灵魂三问：
vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));
错1：一开始我把所有都初始化为0了
错2：uint64我一开始写的是int

1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
	int numDistinct(string s, string t) {
		vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));
		for (int i = 0; i < s.size(); i++) dp[i][0] = 1;
		for (int j = 1; j < t.size(); j++) dp[0][j] = 0;
		for (int i = 1; i <= s.size(); i++) {
			for (int j = 1; j <= t.size(); j++) {
				if (s[i - 1] == t[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
				}
				else {
					dp[i][j] = dp[i - 1][j];
				}
			}
		}
		return dp[s.size()][t.size()];
	}
};

```



### 39-583. 两个字符串的删除操作
```题目描述：
题目来源
https://leetcode.cn/problems/delete-operation-for-two-strings/description/
题目描述
给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。
每步 可以删除任意一个字符串中的一个字符。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i以字符串word1的i-1的位置为结尾
j以字符串word2的j-1的位置为结尾
dp[i][j]表示最小步数
2.递推公式
                if (word1[i - 1] == word2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2));

                }




3.dp数组如何初始化

        for (int i = 0; i <= len1; i++) dp[i][0] = i;
        for (int j = 0; j <= len2; j++) dp[0][j] = j;
        当空字符串为结尾时，最小步数就是字符串的长度


4.遍历顺序
从i=1到size()
    4.1等号要不要带上
    带上！

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size();
        int len2 = word2.size();

        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1));

        for (int i = 0; i <= len1; i++) dp[i][0] = i;
        for (int j = 0; j <= len2; j++) dp[0][j] = j;

        for (int i = 1; i <= len1; i++)
        {
            for (int j = 1; j <= len2; j++)
            {
                if (word1[i - 1] == word2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2));

                }
            }
        }

        return dp[len1][len2];


    }
};
```



### 40-72. 编辑距离
```题目描述：
题目来源
https://leetcode.cn/problems/edit-distance/description/
题目描述
给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字符
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i:word1以i-1为结尾
j:word2以j-1为结尾
dp[i][j]表示最少操作数

2.递推公式
				if(word1[i-1]==word2[j-1])
					dp[i][j]=dp[i-1][j-1];
                else
                {
					dp[i][j]=min(dp[i-1][j-1] + 1,min(dp[i-1][j] + 1,dp[i][j-1] + 1));
				}

3.dp数组如何初始化

        for (int i = 0; i <= n1; i++)dp[i][0] = i;
        for (int j = 0; j <= n2; j++)dp[0][j] = j;

4.遍历顺序
 for(int i=1;i<=n1;i++)
            for (int j = 1; j <= n2; j++)
    4.1等号要不要带上
    1

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1));

        for (int i = 0; i <= n1; i++)dp[i][0] = i;
        for (int j = 0; j <= n2; j++)dp[0][j] = j;


        for(int i=1;i<=n1;i++)
            for (int j = 1; j <= n2; j++)
            {
				if(word1[i-1]==word2[j-1])
					dp[i][j]=dp[i-1][j-1];
                else
                {
					dp[i][j]=min(dp[i-1][j-1] + 1,min(dp[i-1][j] + 1,dp[i][j-1] + 1));
				}
			}

        return dp[n1][n2];

    }
};
```

### 41-647. 回文子串个数
```题目描述：
题目来源
https://leetcode.cn/problems/palindromic-substrings/description/
题目描述
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i表示在左边
j表示在右边
dp[i][j]表示是否是回文子串

2.递推公式
if nums[i]==nums[j]
    if j-i <=1 (包含单个字符情况，和两个字符相同相邻情况)
	   dp[i][j]=true;
	    ret++
    else if (dp[i][j]==dp[i+1][j-1]) (其他情况)
		dp[i][j]=true
        ret++

3.dp数组如何初始化
全为false
4.遍历顺序
i从size-1到0（带等于号）
j从i到size（不带等于号）
    4.1等号要不要带上
    

5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size();
        vector<vector<bool>> dp(n+1, vector<bool>(n+1,false));



        int ret = 0;
        for (int i = n-1; i >= 0; i--)
        {
            for (int j = i; j < n; j++)
            {
                if (s[i] == s[j])
                {
                    if ((j - i) <= 1)
                    {
                        ret++;
;                       dp[i][j] = true;
                    }
                    else if(
                        dp[i][j] = dp[i + 1][j - 1])
                    {
                        					ret++;
						dp[i][j] = true;
					}


                }

            }
        }


        return ret;


    }
};

```


### 42-516. 最长回文子序列

```题目描述：
题目来源
https://leetcode.cn/problems/longest-palindromic-subsequence/description/
题目描述
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
辅助：
```

```
1.dp数组以及下标的含义
dp[i][j]
i表示在左边
j表示在右边
dp[i][j]表示最长回文子序列的长度

2.递推公式
if(s[i]==s[j])
dp[i][j]=dp i+1 j-1  +2
else
dp[i][j]=max(dp[i+1][j],dp[i][j_1])

3.dp数组如何初始化
全为0
对角线全为1

4.遍历顺序（等号要不要带上）
i从n-1到0，带等号
j从i+1到n，不带等号
5.打印dp数组

```


```
 for (int j = i+1 ; j < n; j++)
这里我一开始写的是 j=i
这样写的话下面的 dp[i][j] = dp[i + 1][j - 1] + 2;就完全错乱了


出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n,vector<int>(n,0));
        for(int i=0;i<n;i++) dp[i][i]=1;

        for (int i = n - 1; i >= 0; i--)
        {
            for (int j = i+1 ; j < n; j++)
            {
                if (s[i] == s[j])
                {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else
                {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][n - 1];
    }
};



```
#### 做题格式

```题目描述：
题目来源

题目描述

辅助：
```

```
1.dp数组以及下标的含义
2.递推公式
3.dp数组如何初始化
4.遍历顺序（等号要不要带上）
5.打印dp数组

```


```
出错原因：灵魂三问：
1. 这道题⽬我举例推导状态转移公式了么？
2. 我打印dp数组的⽇志了么？
3. 打印出来了dp数组和我想的⼀样么？
```

```c++

```


